<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>일본어 단어 학습</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Noto Sans KR', 'Noto Sans JP', sans-serif;
        }
        .card {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
            transition: visibility 0s 0.3s, opacity 0.3s ease-out, height 0.3s ease-out;
        }
        .content-visible {
            visibility: visible;
            opacity: 1;
            height: auto;
            transition: opacity 0.3s ease-in, height 0.3s ease-in;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 0.5rem;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .memorized-item { background-color: #E0F2FE; }
        .not-memorized-item { background-color: #FEF3C7; }
        .hidden { display: none; }
        .choice-button {
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .choice-button.correct {
            background-color: #34D399 !important;
            border-color: #34D399 !important;
            color: white !important;
        }
        .choice-button.incorrect {
            background-color: #F87171 !important;
            border-color: #F87171 !important;
            color: white !important;
        }
        .choice-button.selected-incorrect {
            background-color: #F87171 !important;
            border-color: #F87171 !important;
            color: white !important;
        }
        .choice-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .word-display { font-family: 'Noto Sans JP', sans-serif; }
        .reading-display { font-family: 'Noto Sans JP', sans-serif; font-size: 0.9em; color: #555; }
        .meaning-display { font-family: 'Noto Sans KR', sans-serif; }
        .top-icon-button {
            color: #4B5563;
            padding: 0.5rem;
            border-radius: 9999px;
            font-size: 1.25rem;
        }
        .top-icon-button:hover {
            color: #1F2937;
            background-color: #E5E7EB;
        }
        .settings-modal-button {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.375rem;
            font-weight: 500;
            color: #374151;
            background-color: #F3F4F6;
            border: 1px solid #D1D5DB;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .settings-modal-button:hover:not(:disabled) {
            background-color: #E5E7EB;
            border-color: #9CA3AF;
        }
        .settings-modal-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .settings-modal-button i {
            margin-right: 0.75rem;
            color: #4B5563;
            width: 1.25rem;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-green-400 via-cyan-500 to-blue-600 min-h-screen flex flex-col items-center justify-center p-2 sm:p-4 selection:bg-cyan-300 selection:text-cyan-900">

<div id="learningModeContainer" class="flex justify-center w-full">
    <div class="bg-white shadow-2xl rounded-xl p-4 sm:p-6 w-full sm:w-[672px] card transform transition-all duration-500 ease-in-out">
        <div id="appTopBar" class="w-full flex justify-between items-center py-2 mb-3">
            <button id="playPauseButton" class="top-icon-button focus:outline-none">
                <i class="fas fa-play"></i>
            </button>
            <button id="settingsButton" class="top-icon-button focus:outline-none">
                <i class="fas fa-cog"></i>
            </button>
        </div>
        <div>
            <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-600 to-blue-700 mb-4 sm:mb-6">일본어 단어 학습</h1>
            <div class="flex justify-between items-center mb-2">
                <div id="wordIdEl" class="text-xs sm:text-sm text-gray-500"></div>
                <button id="toggleMemorizedButton" class="text-xs sm:text-sm py-1 px-2 rounded-md focus:outline-none"></button>
            </div>
            <div id="wordDisplayContainer" class="w-full text-center mb-3 sm:mb-4 p-3 sm:p-4 bg-cyan-50 rounded-lg">
                <div id="wordFormEl" class="word-display text-2xl sm:text-3xl md:text-4xl font-semibold text-cyan-700"></div>
                <div id="wordReadingElContainer" class="content-hidden">
                    <div id="wordReadingEl" class="reading-display text-lg sm:text-xl md:text-2xl text-cyan-600 mt-1"></div>
                </div>
            </div>
            <div id="detailsContainer">
                <div id="meaningContainer" class="content-hidden">
                    <h2 class="text-base sm:text-lg md:text-xl font-semibold text-blue-700 mt-3 sm:mt-4 mb-1 sm:mb-2">뜻:</h2>
                    <p id="wordMeaningEl" class="meaning-display text-gray-700 bg-blue-50 p-2 sm:p-3 rounded-md text-sm sm:text-base md:text-lg"></p>
                </div>
            </div>
        </div>
        <div class="mt-6 sm:mt-8 space-y-3">
            <div class="flex flex-col sm:flex-row sm:gap-x-3 items-stretch space-y-3 sm:space-y-0">
                <button id="revealHiraganaButton" class="w-full sm:flex-1 bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2.5 sm:py-3 px-5 sm:px-6 rounded-lg shadow-md text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-purple-400 flex items-center justify-center">
                    히라가나 보기
                </button>
                <button id="revealMeaningButton" class="w-full sm:flex-1 bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2.5 sm:py-3 px-5 sm:px-6 rounded-lg shadow-md text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-teal-400 flex items-center justify-center mt-3 sm:mt-0">
                    한글 뜻 보기
                </button>
            </div>
            <div class="flex items-center gap-x-3 mt-3">
                <button id="prevButton" class="flex-1 bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2.5 sm:py-3 px-4 rounded-lg shadow-md text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-sky-300">
                    이전
                </button>
                <button id="nextButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-semibold py-2.5 sm:py-3 px-4 rounded-lg shadow-md text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-red-300">
                    다음
                </button>
            </div>
        </div>
    </div>
</div>

<div id="testModeContainer" class="hidden bg-white shadow-2xl rounded-xl p-4 sm:p-6 w-full max-w-2xl card transform transition-all duration-500 ease-in-out">
    <div>
        <h2 class="text-xl sm:text-2xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-teal-500 to-cyan-500 mb-4 sm:mb-6">단어 학습 (발음 선택)</h2>
        <div id="testProgressEl" class="text-sm text-gray-600 mb-2 text-center"></div>
        <div id="testWordFormEl" class="w-full text-lg sm:text-xl md:text-2xl font-semibold text-teal-700 mb-3 p-3 sm:p-4 bg-teal-50 rounded-lg text-center word-display"></div>
        <div id="testChoicesEl" class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
        </div>
        <div id="testResultEl" class="text-center font-semibold mb-4 p-2 rounded-md min-h-[2.5rem] meaning-display">
        </div>
    </div>
    <div class="mt-6 sm:mt-8 flex flex-col sm:flex-row justify-between items-center space-y-3 sm:space-y-0 sm:space-x-4">
        <button id="quitTestButton" class="w-full sm:w-1/3 bg-red-500 hover:bg-red-600 text-white font-semibold py-2.5 px-5 rounded-lg shadow-md text-sm focus:outline-none focus:ring-2 focus:ring-red-400">
            학습 종료
        </button>
        <button id="nextTestItemButton" class="w-full sm:w-1/3 bg-cyan-500 hover:bg-cyan-600 text-white font-semibold py-2.5 px-5 rounded-lg shadow-md text-sm focus:outline-none focus:ring-2 focus:ring-cyan-400" disabled>
            다음 문제
        </button>
    </div>
</div>

<div id="allWordsModal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="closeAllWordsModalButton">&times;</span>
        <h2 class="text-xl sm:text-2xl font-bold text-center text-indigo-600 mb-4">전체 단어 목록</h2>
        <div id="allWordsListEl" class="space-y-2">
        </div>
    </div>
</div>

<div id="settingsModal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="closeSettingsModalButton">&times;</span>
        <h2 class="text-xl sm:text-2xl font-bold text-center text-indigo-600 mb-6">설정</h2>
        <button id="shuffleCardsButton" class="settings-modal-button">
            <i class="fas fa-random"></i> 카드 순서 섞기
        </button>
        <button id="resetCardOrderButton" class="settings-modal-button" disabled>
            <i class="fas fa-undo"></i> 카드 순서 원래대로
        </button>
        <button id="openAllWordsListFromSettingsButton" class="settings-modal-button">
            <i class="fas fa-list-ul"></i> 전체 단어 목록 보기
        </button>
        <button id="switchModeInSettingsButton" class="settings-modal-button">
            <i class="fas fa-vial"></i> 학습/테스트 모드 전환
        </button>
    </div>
</div>


<script>
    const rawWordData = `
間	あいだ, 사이
会う	あう, 만나다
青い	あおい, 파랗다
明るい	あかるい, 밝다
赤い	あかい, 빨갛다
秋	あき, 가을
空く	あく, 비다
開く	あく, 열리다
開ける	あける, 열다
足	あし, 발
朝	あさ, 아침
新しい	あたらしい, 새롭다
暑い	あつい, 덥다
暑さ	あつさ, 더위
集まる	あつまる, 모이다
兄	あに, 형/오빠
姉	あね, 언니/누나
安心	あんしん, 안심
洗う	あらう, 씻다
歩く	あるく, 걷다
言う	いう, 말하다
以下	いか, 이하
以外	いがい, 이외
意見	いけん, 의견
医者	いしゃ, 의사
以上	いじょう, 이상
一度	いちど, 한 번
一週間	いっしゅうかん, 일주일
以内	いない, 이내
池	いけ, 연못
石	いし, 돌
急ぐ	いそぐ, 서두르다
糸	いと, 실
田舎	いなか, 시골
犬	いぬ, 개
入口	いりぐち, 입구
色	いろ, 색깔
妹	いもうと, 여동생
生まれる	うまれる, 태어나다
歌	うた, 노래
歌う	うたう, 노래를 부르다
写す	うつす, 베끼다, 찍다
海	うみ, 바다
売る	うる, 팔다
売れる	うれる, 팔리다, 팔 수 있다
動く	うごく, 움직이다
動きだす	うごきだす, 움직이기 시작하다
運転	うんてん, 운전
運動	うんどう, 운동
映画	えいが, 영화
映画館	えいがかん, 영화관
英語	えいご, 영어
駅	えき, 역
駅員	えきいん, 역무원
描く	えがく, 그리다
営業	えいぎょう, 영업
多い	おおい, 많다
大きさ	おおきさ, 크기
起きる	おきる, 일어나다
屋上	おくじょう, 옥상
送る	おくる, 보내다
行う	おこなう, 행하다
教える	おしえる, 가르치다
押す	おす, 누르다, 밀다
お正月	おしょうがつ, 양력설
音	おと, 소리
弟	おとうと, 남동생
おもちゃ	おもちゃ, 장난감
お茶	おちゃ, 차
お兄さん	おにいさん, 오빠
お姉さん	おねえさん, 언니, 누나
同じだ	おなじだ, 같다
重い	おもい, 무겁다
思い出す	おもいだす, 생각나다, 떠올리다
思う	おもう, 생각하다
泳ぐ	およぐ, 헤엄치다
終わる	おわる, 끝나다
音楽	おんがく, 음악
親指	おやゆび, 엄지손가락
会社	かいしゃ, 회사
会話	かいわ, 회화
会場	かいじょう, 회장
買う	かう, 사다
帰り	かえり, 돌아옴
帰る	かえる, 돌아가다
顔	かお, 얼굴
火事	かじ, 화재
書き方	かきかた, 쓰는 법
数える	かぞえる, 세다
風	かぜ, 바람
貸す	かす, 빌려주다
家族	かぞく, 가족
片付ける	かたづける, 정리하다
方	かた, 분
体	からだ, 몸
借りる	かりる, 빌리다
軽い	かるい, 가볍다
川	かわ, 강
代わり	かわり, 대신
考える	かんがえる, 생각하다
考え方	かんがえかた, 생각하는 방식
漢字	かんじ, 한자
気分	きぶん, 기분
着物	きもの, 일본 옷
教	きょう, 오늘
教室	きょうしつ, 교실
近所	きんじょ, 근처
銀行	ぎんこう, 은행
銀色	ぎんいろ, 은색
空気	くうき, 공기
空港	くうこう, 공항
首	くび, 목
雲	くも, 구름
黒い	くろい, 검다
薬	くすり, 약
区	く, 구
経験	けいけん, 경험
計画	けいかく, 계획
研究	けんきゅう, 연구
研究会	けんきゅうかい, 연구회
県	けん, 현
公園	こうえん, 공원
工事	こうじ, 공사
工場	こうじょう, 공장
工業	こうぎょう, 공업
氷	こおり, 얼음
声	こえ, 목소리
心	こころ, 마음
答える	こたえる, 대답하다
小鳥	ことり, 작은 새
今年	ことし, 올해
今度	こんど, 이번, 다음
米	こめ, 쌀
作文	さくぶん, 작문
産業	さんぎょう, 산업
寒い	さむい, 춥다
皿	さら, 접시
仕事	しごと, 일
時代	じだい, 시대
自転車	じてんしゃ, 자전거
自分	じぶん, 자신
辞書	じしょ, 사전
市民	しみん, 시민
死ぬ	しぬ, 죽다
質問	しつもん, 질문
品物	しなもの, 물건
写真	しゃしん, 사진
写真家	しゃしんか, 사진작가
社長	しゃちょう, 사장
十分	じゅうぶん, 충분
出口	でぐち, 출구
出発	しゅっぱつ, 출발
主人	しゅじん, 주인
住所	じゅうしょ, 주소
授業	じゅぎょう, 수업
食事	しょくじ, 식사
食堂	しょくどう, 식당
食料品	しょくりょうひん, 식료품
調べる	しらべる, 조사하다
知る	しる, 알다
白い	しろい, 하얗다
進む	すすむ, 나아가다, 진행되다
好きだ	すきだ, 좋아하다
少し	すこし, 조금
住む	すむ, 살다
水道	すいどう, 수도
世界	せかい, 세계
生産	せいさん, 생산
西洋	せいよう, 서양
説明	せつめい, 설명
世話	せわ, 보살핌, 도와줌
席	せき, 자리
祖母	そぼ, 조모, 할머니
空	そら, 하늘
大使	たいし, 대사
大使館	たいしかん, 대사관
大切だ	たいせつだ, 소중하다
台所	だいどころ, 부엌
台風	たいふう, 태풍
正しい	ただしい, 바르다, 옳다
立つ	たつ, 서다
建物	たてもの, 건물
楽しい	たのしい, 즐겁다
足りない	たりない, 부족하다
足りる	たりる, 충분하다
茶色	ちゃいろ, 갈색
地下鉄	ちかてつ, 지하철
力	ちから, 힘
地図	ちず, 지도
注意	ちゅうい, 주의
中止	ちゅうし, 중지
地理	ちり, 지리
使う	つかう, 사용하다
着く	つく, 도착하다
机	つくえ, 책상
作る	つくる, 만들다
都合	つごう, 사정, 형편
強い	つよい, 강하다
手紙	てがみ, 편지
店	みせ, 가게
店員	てんいん, 점원
電話代	でんわだい, 전화요금
動物	どうぶつ, 동물
～度	～ど, ~번
特に	とくに, 특히
特別だ	とくべつだ, 특별하다
図書館	としょかん, 도서관
止まる	とまる, 멈추다
鳥	とり, 새
遠い	とおい, 멀다
遠く	とおく, 멀리
通る	とおる, 지나가다
土曜日	どようび, 토요일
夏	なつ, 여름
何枚	なんまい, 몇 매, 몇 장
習う	ならう, 배우다
日記	にっき, 일기
二台	にだい, 2대, 두 대
入院	にゅういん, 입원
眠い	ねむい, 졸리다
眠る	ねむる, 자다
乗る	のる, 타다
荷物	にもつ, 짐
飲む	のむ, 마시다
売店	ばいてん, 매점
運ぶ	はこぶ, 운반하다, 옮기다
始める	はじめる, 시작하다
場所	ばしょ, 장소
走る	はしる, 달리다
働く	はたらく, 일하다
発音	はつおん, 발음
花	はな, 꽃
春	はる, 봄
早く	はやく, 일찍, 빨리
林	はやし, 숲
光	ひかり, 빛
光る	ひかる, 빛나다
低い	ひくい, 낮다
引く	ひく, 끌다, 찾다
病院	びょういん, 병원
昼	ひる, 낮
昼ごはん	ひるごはん, 점심밥
昼休み	ひるやすみ, 점심시간
広い	ひろい, 넓다
服	ふく, 옷
不便だ	ふべんだ, 불편하다
船	ふね, 배
冬	ふゆ, 겨울
古い	ふるい, 오래된, 낡다
文	ぶん, 문장, 글
文学	ぶんがく, 문학
便利だ	べんりだ, 편리하다
勉強	べんきょう, 공부
本屋	ほんや, 서점
毎朝	まいあさ, 매일 아침
町	まち, 시내, 도시
待つ	まつ, 기다리다
間に合う	まにあう, 시간에 맞추다
短い	みじかい, 짧다
港	みなと, 항구
村	むら, 마을
目	め, 눈
持つ	もつ, 들다, 가지다
持てる	もてる, 들 수 있다
森	もり, 숲
問題	もんだい, 문제
門	もん, 문
野菜	やさい, 채소
役	やく, 역할
安い	やすい, 싸다
山道	やまみち, 산길
夕方	ゆうがた, 저녁때
夕飯	ゆうはん, 저녁밥
有名だ	ゆうめいだ, 유명하다
雪	ゆき, 눈
用事	ようじ, 볼일, 용무
洋服	ようふく, 양복, 옷
予習	よしゅう, 예습
予定	よてい, 예정
予報	よほう, 예보
夜	よる, 밤
弱い	よわい, 약하다
来週	らいしゅう, 다음 주
料理	りょうり, 요리
旅行	りょこう, 여행
旅館	りょかん, 여관
利用	りよう, 이용
別れる	わかれる, 헤어지다
悪い	わるい, 나쁘다
私	わたくし, 저
`;

    let wordData = [];
    let originalWordData = [];
    let isShuffled = false;
    let currentCardIndex = 0;
    let hiraganaVisible = false;
    let meaningVisible = false;
    let memorizedStatus = {};
    let isAutoPlaying = false;
    let speechQueue = [];
    let currentSpeechUtteranceIndex = 0;
    const synth = window.speechSynthesis;
    let voices = [];
    let preferredKoreanVoice = null;
    let preferredJapaneseVoice = null;
    let isTestMode = false;
    let currentTestItemIndex = 0;
    let shuffledTestData = [];
    let score = 0;
    let totalQuestionsInTest = 0;

    const learningModeContainerEl = document.getElementById('learningModeContainer');
    const appTopBarEl = document.getElementById('appTopBar');
    const wordIdEl = document.getElementById('wordIdEl');
    const wordFormEl = document.getElementById('wordFormEl');
    const wordReadingElContainer = document.getElementById('wordReadingElContainer');
    const wordReadingEl = document.getElementById('wordReadingEl');
    const wordMeaningEl = document.getElementById('wordMeaningEl');
    const meaningContainerEl = document.getElementById('meaningContainer');
    const revealHiraganaButton = document.getElementById('revealHiraganaButton');
    const revealMeaningButton = document.getElementById('revealMeaningButton');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    const toggleMemorizedButtonEl = document.getElementById('toggleMemorizedButton');
    const playPauseButtonEl = document.getElementById('playPauseButton');
    const settingsButtonEl = document.getElementById('settingsButton');
    const testModeContainerEl = document.getElementById('testModeContainer');
    const testProgressEl = document.getElementById('testProgressEl');
    const testWordFormEl = document.getElementById('testWordFormEl');
    const testChoicesEl = document.getElementById('testChoicesEl');
    const testResultEl = document.getElementById('testResultEl');
    const quitTestButtonEl = document.getElementById('quitTestButton');
    const nextTestItemButtonEl = document.getElementById('nextTestItemButton');

    const allWordsModalEl = document.getElementById('allWordsModal');
    const closeAllWordsModalButtonEl = document.getElementById('closeAllWordsModalButton');
    const allWordsListEl = document.getElementById('allWordsListEl');

    const settingsModalEl = document.getElementById('settingsModal');
    const closeSettingsModalButtonEl = document.getElementById('closeSettingsModalButton');
    const shuffleCardsButtonEl = document.getElementById('shuffleCardsButton');
    const resetCardOrderButtonEl = document.getElementById('resetCardOrderButton');
    const openAllWordsListFromSettingsButtonEl = document.getElementById('openAllWordsListFromSettingsButton');
    const switchModeInSettingsButtonEl = document.getElementById('switchModeInSettingsButton');


    function parseWordData() {
        const lines = rawWordData.trim().split('\n');
        const parsedData = lines.map((line, index) => {
            const parts = line.split('\t');
            if (parts.length < 2) return null;
            const form = parts[0].trim();
            const readingAndMeaning = parts[1].split(',');
            if (readingAndMeaning.length < 2) return null;
            const reading = readingAndMeaning[0].trim();
            const meaning = readingAndMeaning.slice(1).join(',').trim();
            return { id: index + 1, form, reading, meaning };
        }).filter(item => item !== null);
        wordData = [...parsedData];
        originalWordData = [...parsedData];
    }

    function loadVoices() {
        voices = synth.getVoices();
        const koreanVoicePreferences = ['Microsoft Heami Online (Natural) - Korean (Korea)', 'Google 한국의', '유나 (고품질)', '소라 (고품질)', '유나', '소라', 'Yuna (Enhanced)', 'Sora (Enhanced)', 'Yuna', 'Sora'];
        for (const name of koreanVoicePreferences) {
            const voice = voices.find(v => v.lang === 'ko-KR' && v.name === name);
            if (voice) { preferredKoreanVoice = voice; break; }
        }
        if (!preferredKoreanVoice) preferredKoreanVoice = voices.find(v => v.lang === 'ko-KR' && (v.name.toLowerCase().includes('female') || v.name.includes('여성')));
        if (!preferredKoreanVoice) preferredKoreanVoice = voices.find(v => v.lang === 'ko-KR');

        const japaneseVoicePreferences = ['Google 日本語', 'Microsoft Ayumi Online (Natural) - Japanese (Japan)', 'Microsoft Haruka Online (Natural) - Japanese (Japan)', 'Microsoft Haruka Desktop - Japanese', 'Kyoko (Enhanced)', 'Otoya (Enhanced)', 'Kyoko', 'Otoya'];
        for (const name of japaneseVoicePreferences) {
            const voice = voices.find(v => v.lang === 'ja-JP' && v.name === name);
            if (voice) { preferredJapaneseVoice = voice; break; }
        }
        if (!preferredJapaneseVoice) preferredJapaneseVoice = voices.find(v => v.lang === 'ja-JP' && (v.name.toLowerCase().includes('female') || v.name.includes('女性')));
        if (!preferredJapaneseVoice) preferredJapaneseVoice = voices.find(v => v.lang === 'ja-JP');
    }

    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = loadVoices;
    }
    loadVoices();

    function speak(text, lang, callback) {
        if (voices.length === 0) loadVoices();
        if (synth.speaking) synth.cancel();

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = lang;
        let targetVoice = null;
        if (lang === 'ko-KR') targetVoice = preferredKoreanVoice;
        else if (lang === 'ja-JP') targetVoice = preferredJapaneseVoice;

        if (targetVoice) utterance.voice = targetVoice;
        else {
            const fallbackVoice = voices.find(v => v.lang === lang);
            if (fallbackVoice) utterance.voice = fallbackVoice;
        }
        utterance.onend = () => { if (callback) callback(); };
        utterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror:', event.error, event);
            const isCancellationError = event.error === 'canceled' || event.error === 'interrupted';
            if (isAutoPlaying && !isCancellationError) {
                if (typeof alert !== 'undefined') alert(`음성 재생 중 오류: ${event.error || 'N/A'}. 자동 재생 중지.`);
                stopAutoPlay();
            }
            if (callback) callback();
        };
        synth.speak(utterance);
    }

    function cleanTextForSpeech(text) { return text.replace(/\([^)]*\)/g, '').trim(); }

    function playCurrentCardAudio() {
        if (!isAutoPlaying || wordData.length === 0) return;
        const card = wordData[currentCardIndex];
        if (memorizedStatus[card.id] && wordData.length > 1) {
            playNextCard();
            return;
        }

        speechQueue = [];
        currentSpeechUtteranceIndex = 0;
        speechQueue.push({ text: card.reading, lang: 'ja-JP' });
        speechQueue.push({ text: cleanTextForSpeech(card.meaning), lang: 'ko-KR' });
        playNextSpeechInQueue();
    }

    function playNextSpeechInQueue() {
        if (!isAutoPlaying || currentSpeechUtteranceIndex >= speechQueue.length) {
            if (isAutoPlaying) { setTimeout(playNextCard, 700); }
            return;
        }
        const speechItem = speechQueue[currentSpeechUtteranceIndex];
        speak(speechItem.text, speechItem.lang, () => {
            currentSpeechUtteranceIndex++;
            playNextSpeechInQueue();
        });
    }

    function playNextCard() {
        if (!isAutoPlaying || wordData.length === 0) return;
        currentCardIndex = (currentCardIndex + 1) % wordData.length;
        hiraganaVisible = true;
        meaningVisible = true;
        displayCard();
        playCurrentCardAudio();
    }

    function startAutoPlay() {
        if (isTestMode || wordData.length === 0) return;
        if (synth.speaking) synth.cancel();
        isAutoPlaying = true;
        playPauseButtonEl.innerHTML = '<i class="fas fa-pause"></i>';
        currentSpeechUtteranceIndex = 0;
        hiraganaVisible = true;
        meaningVisible = true;
        displayCard();
        playCurrentCardAudio();
    }

    function stopAutoPlay() {
        isAutoPlaying = false;
        synth.cancel();
        speechQueue = [];
        currentSpeechUtteranceIndex = 0;
        playPauseButtonEl.innerHTML = '<i class="fas fa-play"></i>';
    }

    function loadMemorizedStatus() {
        const storedStatus = localStorage.getItem('japaneseWordMemorizedStatus_v4');
        if (storedStatus) { memorizedStatus = JSON.parse(storedStatus); }
    }
    function saveMemorizedStatus() {
        localStorage.setItem('japaneseWordMemorizedStatus_v4', JSON.stringify(memorizedStatus));
    }
    function updateMemorizedButton() {
        if (wordData.length === 0) return;
        const card = wordData[currentCardIndex];
        if (memorizedStatus[card.id]) {
            toggleMemorizedButtonEl.textContent = '암기 ✅';
            toggleMemorizedButtonEl.className = 'text-xs sm:text-sm py-1 px-2 rounded-md focus:outline-none bg-green-200 hover:bg-green-300 text-green-700';
        } else {
            toggleMemorizedButtonEl.textContent = '암기 ❌';
            toggleMemorizedButtonEl.className = 'text-xs sm:text-sm py-1 px-2 rounded-md focus:outline-none bg-gray-200 hover:bg-gray-300 text-gray-700';
        }
    }

    function displayCard() {
        if (wordData.length === 0) return;
        const card = wordData[currentCardIndex];
        wordIdEl.textContent = `ID: ${String(card.id).padStart(String(originalWordData.length).length, '0')}`;
        wordFormEl.textContent = card.form;
        wordReadingEl.textContent = card.reading;
        wordMeaningEl.textContent = card.meaning;

        wordFormEl.onclick = () => speak(card.reading, 'ja-JP');
        wordReadingEl.onclick = () => speak(card.reading, 'ja-JP');
        wordMeaningEl.onclick = () => speak(card.meaning, 'ko-KR');

        if (hiraganaVisible) showHiraganaDOM(); else hideHiraganaDOM();
        if (meaningVisible) showMeaningDOM(); else hideMeaningDOM();
        updateRevealButtonsText();
        updateMemorizedButton();
    }

    function hideHiraganaDOM() {
        wordReadingElContainer.classList.remove('content-visible');
        wordReadingElContainer.classList.add('content-hidden');
    }
    function showHiraganaDOM() {
        wordReadingElContainer.classList.remove('content-hidden');
        wordReadingElContainer.classList.add('content-visible');
    }
    function hideMeaningDOM() {
        meaningContainerEl.classList.remove('content-visible');
        meaningContainerEl.classList.add('content-hidden');
    }
    function showMeaningDOM() {
        meaningContainerEl.classList.remove('content-hidden');
        meaningContainerEl.classList.add('content-visible');
    }

    function updateRevealButtonsText() {
        revealHiraganaButton.textContent = hiraganaVisible ? '히라가나 숨기기' : '히라가나 보기';
        revealMeaningButton.textContent = meaningVisible ? '한글 뜻 숨기기' : '한글 뜻 보기';
    }

    function toggleHiragana() {
        hiraganaVisible = !hiraganaVisible;
        if (hiraganaVisible) showHiraganaDOM(); else hideHiraganaDOM();
        updateRevealButtonsText();
    }
    function toggleMeaning() {
        meaningVisible = !meaningVisible;
        if (meaningVisible) showMeaningDOM(); else hideMeaningDOM();
        updateRevealButtonsText();
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    function generateTestChoices(correctReading, allWordData) {
        const choices = [correctReading];
        let otherReadings = [...new Set(allWordData.map(item => item.reading))].filter(r => r !== correctReading);
        shuffleArray(otherReadings);
        for (let i = 0; i < 3 && i < otherReadings.length; i++) { choices.push(otherReadings[i]); }
        let attempts = 0;
        while (choices.length < 4 && otherReadings.length > (choices.length -1 + attempts) && attempts < 10) {
            const nextOption = otherReadings[choices.length -1 + attempts];
            if (nextOption && !choices.includes(nextOption)) { choices.push(nextOption); }
            attempts++;
        }
        return shuffleArray(choices);
    }
    function loadTestItem() {
        if (wordData.length === 0) return;
        const currentWord = shuffledTestData[currentTestItemIndex];

        if (currentTestItemIndex >= totalQuestionsInTest) {
            testResultEl.innerHTML = `학습 종료! 최종 점수: ${score} / ${totalQuestionsInTest}`;
            testResultEl.className = 'text-center font-semibold mb-4 p-2 rounded-md bg-blue-100 text-blue-700 min-h-[2.5rem] meaning-display';
            testWordFormEl.textContent = "모든 문제를 다 풀었습니다!";
            testChoicesEl.innerHTML = '';
            nextTestItemButtonEl.disabled = true;
            quitTestButtonEl.textContent = "낱말카드로";
            return;
        }

        testProgressEl.textContent = `문제 ${currentTestItemIndex + 1} / ${totalQuestionsInTest} (ID: ${String(currentWord.id).padStart(String(originalWordData.length).length, '0')})`;
        testWordFormEl.textContent = currentWord.form;
        testResultEl.textContent = '';
        testResultEl.className = 'text-center font-semibold mb-4 p-2 rounded-md min-h-[2.5rem] meaning-display';
        testChoicesEl.innerHTML = '';

        const choices = generateTestChoices(currentWord.reading, wordData);
        if (choices.length < 2) {
            testChoicesEl.innerHTML = '<p class="text-red-500 text-center">보기를 생성하기에 데이터가 부족합니다.</p>';
            nextTestItemButtonEl.disabled = false;
            return;
        }
        choices.forEach(choiceText => {
            const choiceButton = document.createElement('button');
            choiceButton.textContent = choiceText;
            choiceButton.classList.add('choice-button', 'p-3', 'rounded-md', 'border', 'border-gray-300', 'hover:bg-indigo-100', 'focus:outline-none', 'focus:ring-2', 'focus:ring-indigo-400', 'text-sm', 'sm:text-base', 'reading-display');
            choiceButton.addEventListener('click', () => handleTestChoiceSelection(choiceButton, choiceText, currentWord));
            testChoicesEl.appendChild(choiceButton);
        });
        nextTestItemButtonEl.disabled = true;
    }

    function handleTestChoiceSelection(selectedButton, selectedReading, correctWord) {
        const buttons = testChoicesEl.querySelectorAll('button');
        buttons.forEach(button => {
            button.disabled = true;
            button.classList.remove('hover:bg-indigo-100');
            if (button.textContent === correctWord.reading) { button.classList.add('correct'); }
            else if (button === selectedButton && selectedReading !== correctWord.reading) { button.classList.add('selected-incorrect'); }
            else if (button.textContent !== correctWord.reading) { button.classList.add('bg-gray-100', 'text-gray-500', 'border-gray-300', 'opacity-50');}
        });

        let resultHTML = '';
        if (selectedReading === correctWord.reading) {
            resultHTML = `<span class="text-green-700">정답!</span> ${correctWord.form} (<span class="reading-display">${correctWord.reading}</span>): ${correctWord.meaning}`;
            testResultEl.className = 'text-center font-semibold mb-4 p-2 rounded-md bg-green-100 text-green-700 min-h-[2.5rem]';
            score++;
        } else {
            resultHTML = `<span class="text-red-700">오답.</span> 정답: ${correctWord.form} (<span class="reading-display">${correctWord.reading}</span>): ${correctWord.meaning}`;
            testResultEl.className = 'text-center font-semibold mb-4 p-2 rounded-md bg-red-100 text-red-700 min-h-[2.5rem]';
        }
        testResultEl.innerHTML = resultHTML;
        nextTestItemButtonEl.disabled = false;
        nextTestItemButtonEl.focus();
    }

    function toggleAppMode() {
        if (isTestMode) {
            endTestMode();
        } else {
            startTestMode();
        }
        settingsModalEl.style.display = 'none';
    }


    function startTestMode() {
        if (wordData.length === 0) {
            if(typeof alert !== 'undefined') alert("학습할 단어가 없습니다.");
            return;
        }
        isTestMode = true;
        if (isAutoPlaying) stopAutoPlay();
        learningModeContainerEl.classList.add('hidden');
        testModeContainerEl.classList.remove('hidden');
        appTopBarEl.classList.add('hidden');
        switchModeInSettingsButtonEl.innerHTML = '<i class="fas fa-book-open"></i> 낱말카드 모드로';

        shuffledTestData = shuffleArray([...wordData]);
        currentTestItemIndex = 0;
        score = 0;
        totalQuestionsInTest = shuffledTestData.length;
        nextTestItemButtonEl.disabled = true;
        quitTestButtonEl.textContent = "학습 종료";
        testResultEl.textContent = '';
        loadTestItem();
    }
    function endTestMode() {
        isTestMode = false;
        learningModeContainerEl.classList.remove('hidden');
        testModeContainerEl.classList.add('hidden');
        appTopBarEl.classList.remove('hidden');
        switchModeInSettingsButtonEl.innerHTML = '<i class="fas fa-vial"></i> 학습/테스트 모드로';
        if (wordData.length > 0) {
            hiraganaVisible = false;
            meaningVisible = false;
            displayCard();
        }
    }

    function updateSettingsButtonsState() {
        if (resetCardOrderButtonEl) {
            resetCardOrderButtonEl.disabled = !isShuffled;
            if(!isShuffled) {
                resetCardOrderButtonEl.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                resetCardOrderButtonEl.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }
    }


    playPauseButtonEl.addEventListener('click', () => {
        if (isTestMode) return;
        if (isAutoPlaying) stopAutoPlay(); else startAutoPlay();
    });
    settingsButtonEl.addEventListener('click', () => {
        if (isAutoPlaying) stopAutoPlay();
        updateSettingsButtonsState();
        settingsModalEl.style.display = 'block';
    });
    closeSettingsModalButtonEl.addEventListener('click', () => {
        settingsModalEl.style.display = 'none';
    });
    shuffleCardsButtonEl.addEventListener('click', () => {
        if (wordData.length > 0) {
            shuffleArray(wordData);
            currentCardIndex = 0;
            hiraganaVisible = false;
            meaningVisible = false;
            isShuffled = true;
            displayCard();
            if(typeof alert !== 'undefined') alert("카드 순서를 섞었습니다!");
            updateSettingsButtonsState();
        }
        settingsModalEl.style.display = 'none';
    });
    resetCardOrderButtonEl.addEventListener('click', () => {
        if (wordData.length > 0 && originalWordData.length > 0) {
            wordData = [...originalWordData];
            currentCardIndex = 0;
            hiraganaVisible = false;
            meaningVisible = false;
            isShuffled = false;
            displayCard();
            if(typeof alert !== 'undefined') alert("카드 순서를 원래대로 되돌렸습니다.");
            updateSettingsButtonsState();
        }
        settingsModalEl.style.display = 'none';
    });
    openAllWordsListFromSettingsButtonEl.addEventListener('click', () => {
        settingsModalEl.style.display = 'none';
        if (wordData.length === 0) return;
        allWordsListEl.innerHTML = '';
        const currentDataToDisplay = isShuffled ? wordData : originalWordData;
        currentDataToDisplay.forEach((item) => {
            const originalIndex = originalWordData.findIndex(origItem => origItem.id === item.id);

            const listItem = document.createElement('div');
            listItem.classList.add('p-2', 'rounded-md', 'cursor-pointer', 'hover:bg-gray-100', 'flex', 'justify-between', 'items-center', (memorizedStatus[item.id] ? 'memorized-item' : 'not-memorized-item'));
            const wordInfoSpan = document.createElement('span');
            wordInfoSpan.innerHTML = `<span class="word-display">${item.form}</span> <span class="reading-display">(${item.reading})</span>: <span class="meaning-display">${item.meaning}</span>`;
            wordInfoSpan.classList.add('text-sm', 'sm:text-base');
            const statusSpan = document.createElement('span');
            statusSpan.textContent = memorizedStatus[item.id] ? '✅' : '❌';
            statusSpan.classList.add('text-xs', 'sm:text-sm', 'ml-2', 'font-semibold', (memorizedStatus[item.id] ? 'text-green-600' : 'text-red-500'));
            listItem.appendChild(wordInfoSpan);
            listItem.appendChild(statusSpan);
            listItem.addEventListener('click', () => {
                currentCardIndex = wordData.findIndex(wd => wd.id === item.id);
                if (currentCardIndex === -1 && originalWordData.length > 0) {
                    currentCardIndex = originalWordData.findIndex(wd => wd.id === item.id);
                }
                hiraganaVisible = false;
                meaningVisible = false;
                displayCard();
                allWordsModalEl.style.display = 'none';
            });
            allWordsListEl.appendChild(listItem);
        });
        allWordsModalEl.style.display = 'block';
    });
    switchModeInSettingsButtonEl.addEventListener('click', toggleAppMode);

    revealHiraganaButton.addEventListener('click', () => {
        if (isAutoPlaying) stopAutoPlay();
        toggleHiragana();
    });
    revealMeaningButton.addEventListener('click', () => {
        if (isAutoPlaying) stopAutoPlay();
        toggleMeaning();
    });
    prevButton.addEventListener('click', () => {
        if (isAutoPlaying) stopAutoPlay();
        if (wordData.length === 0) return;
        currentCardIndex = (currentCardIndex - 1 + wordData.length) % wordData.length;
        hiraganaVisible = false;
        meaningVisible = false;
        displayCard();
    });
    nextButton.addEventListener('click', () => {
        if (isAutoPlaying) stopAutoPlay();
        if (wordData.length === 0) return;
        currentCardIndex = (currentCardIndex + 1) % wordData.length;
        hiraganaVisible = false;
        meaningVisible = false;
        displayCard();
    });
    toggleMemorizedButtonEl.addEventListener('click', () => {
        if (wordData.length === 0) return;
        const card = wordData[currentCardIndex];
        memorizedStatus[card.id] = !memorizedStatus[card.id];
        updateMemorizedButton();
        saveMemorizedStatus();
    });

    closeAllWordsModalButtonEl.addEventListener('click', () => { allWordsModalEl.style.display = 'none'; });
    window.addEventListener('click', (event) => {
        if (event.target == allWordsModalEl) allWordsModalEl.style.display = 'none';
        if (event.target == settingsModalEl) settingsModalEl.style.display = 'none';
    });
    quitTestButtonEl.addEventListener('click', endTestMode);
    nextTestItemButtonEl.addEventListener('click', () => {
        currentTestItemIndex++;
        loadTestItem();
    });

    function initializeApp() {
        parseWordData();
        loadMemorizedStatus();
        const buttonsToDisable = [playPauseButtonEl, settingsButtonEl, revealHiraganaButton, revealMeaningButton, prevButton, nextButton, toggleMemorizedButtonEl, shuffleCardsButtonEl, openAllWordsListFromSettingsButtonEl, switchModeInSettingsButtonEl, resetCardOrderButtonEl];

        if (wordData.length > 0) {
            hiraganaVisible = false;
            meaningVisible = false;
            displayCard();
            buttonsToDisable.forEach(btn => btn.disabled = false);
        } else {
            wordFormEl.textContent = "단어 데이터가 없습니다.";
            wordReadingElContainer.classList.add('content-hidden');
            meaningContainerEl.classList.add('content-hidden');
            buttonsToDisable.forEach(btn => btn.disabled = true);
            if(typeof alert !== 'undefined') alert("학습할 단어 데이터가 없습니다. 단어 목록을 확인해주세요.");
        }
        learningModeContainerEl.classList.remove('hidden');
        testModeContainerEl.classList.add('hidden');
        appTopBarEl.classList.remove('hidden');
        switchModeInSettingsButtonEl.innerHTML = '<i class="fas fa-vial"></i> 학습/테스트 모드 전환';
        updateSettingsButtonsState();

    }

    initializeApp();
</script>
</body>
</html>
